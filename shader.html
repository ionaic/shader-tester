<!DOCTYPE html>
<html>
<head>
	<style type="text/css">
		body, a, div, p {
			color: #0066CC;
		}
		a {
			text-decoration: none;
		}
		textarea {
			width: 45%;
			height: 45%;
		}
		.top {
			margin: 10px auto;
			top: 0;
			left: 0;
		}
		.nav {
			display: table;
		}
		.nav > * {
			display: table-cell;
			padding: 10px;
		}
		.multi-pane {
			position: absolute;
			top: 50px;
			width: 100%;
			height: 100%;
			margin: 10px auto;
		}
		.multi-pane > * {
			float: left;
		}
		.resizable {
			resize: both;
		}
		.float-clear {
			float: clear !important;
		}
		.invisible {
			display: none;
		}
		.overlay {
			z-index: 10;
			transition: 		background-color 0.3s ease-in 0s;
			-webkit-transition: background-color 0.3s ease-in 0s;
			-moz-transition: 	background-color 0.3s ease-in 0s;
			-o-transition:		background-color 0.3s ease-in 0s;
			-ms-transition:		background-color 0.3s ease-in 0s;
			background-color: rgba(0, 0, 0, 0.0);
			text-shadow: 0.3px 0.3px #000;
			color: #0066CC;
		}
		.overlay:hover {
			background-color: rgba(0, 0, 0, 0.8);
		}
		.gl-console-error {
			color: red;
		}
		#console {
			margin: 10px auto;
			overflow: scroll;
			resize: both;
			/* border: solid 3px #333;*/
		}
		#context {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			z-index: -1;
		}
	</style>
	<script type="text/javascript">
		// utilities
		var gl_console = null;
		
		// error logging
		function CreateConsoleMessage(message) {
			// TODO sanitize the messages
			var p = document.createElement("pre");
			var text = document.createTextNode(message);
			p.appendChild(text);
			return p;
		}
		function LogConsole(message) {
			if (!gl_console) {
				gl_console = document.getElementById("console");
			}
			gl_console.appendChild(CreateConsoleMessage(message));
		}
		function LogConsoleError(message) {
			if (!gl_console) {
				gl_console = document.getElementById("console");
			}
			var console_element = CreateConsoleMessage(message);
			addClass(console_element, "gl-console-error");
			gl_console.appendChild(console_element);
		}
		
		/* add a class */
		function addClass(obj, selected_class) {
			if (obj.className === undefined) {
				obj.className = selected_class;
			}
			else {
				classes = obj.className.split(' ');
				if (classes.indexOf === undefined) {
					// going the long way for older browsers
					for (var i = 0; i < classes.length; i++) {
						if (classes[i] === selected_class) {
							break;
						}
					}
				}
				else {
					var idx = classes.indexOf(selected_class);
					if (idx < 0) {
						classes.push(selected_class);
					}
				}
				obj.className = classes.join(" ");
			}
			return obj;
		}

		/* remove a class */
		function removeClass(obj, selected_class) {
			if (obj.className === undefined) {
				obj.className = "";
			}
			else {
				classes = obj.className.split(' ');
				if (classes.indexOf === undefined) {
					// going the long way for older browsers
					for (var i = 0; i < classes.length; i++) {
						if (classes[i] === selected_class) {
							classes.splice(i, 1);
						}
					}
				}
				else {
					var idx = classes.indexOf(selected_class);
					if (idx >= 0) {
						classes.splice(idx, 1);
					}
				}
				obj.className = classes.join(" ");
			}
			return obj;
		}
	</script>
	<script type="text/javascript">
		var gl;
		var shader = {
			program : null,
			vert : null,
			frag : null,
			geom : null
		};
		var vert_data;
		

		
		function initShaders() {
			if (!gl) {
				LogConsole("In function initShaders, GL not initialized, creating")
				return;
			}
			// create the program
			shader.program = gl.createProgram();
			
			// create the shaders
			shader.vert = gl.createShader(gl.VERTEX_SHADER);
			shader.frag = gl.createShader(gl.FRAGMENT_SHADER);
			
			// load the shader sources
			var vs_el = document.getElementById("vertex-shader");
			var fs_el = document.getElementById("frag-shader");
			gl.shaderSource(shader.vert, vs_el.value);
			gl.shaderSource(shader.frag, fs_el.value);
			
			// compile vertex shader and log errors
			gl.compileShader(shader.vert);
			LogConsole("Compiling vertex shader...");
			if (!gl.getShaderParameter(shader.vert, gl.COMPILE_STATUS)) {
				LogConsoleError(gl.getShaderInfoLog(shader.vert));
			}
			else {
				LogConsole(gl.getShaderParameter(shader.vert, gl.COMPILE_STATUS));
				LogConsole(gl.getShaderInfoLog(shader.vert));
			}
			
			// compile fragment shader and log errors
			gl.compileShader(shader.frag);
			LogConsole("Compiling fragment shader...");
			if (!gl.getShaderParameter(shader.frag, gl.COMPILE_STATUS)) {
				LogConsoleError(gl.getShaderInfoLog(shader.frag));
			}
			else {
				LogConsole(gl.getShaderParameter(shader.frag, gl.COMPILE_STATUS));
				LogConsole(gl.getShaderInfoLog(shader.frag));
			}
		}
		
		function updateShaders() {
			if (!gl) {
				LogConsole("In function updateShaders, GL not initialized, creating")
				return;
			}
			LogConsole("Update Shaders");
		}
		
		function initBuffers() {
			if (!gl) {
				LogConsole("In function initBuffers, GL not initialized, creating")
				return;
			}
		}

		function init(canvas) {
			try {
				gl = canvas.getContext("webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
			catch (e) {}
			if (!gl) {
				LogConsoleError("Could not initialize WebGL context");
			}
			else {
				LogConsole("WebGL Context initialized");
			}
			
			initShaders();
			
			updatePaneVisibility();
			parseObj(pane_elements.vertices.value);
		}
	</script>
	<script type="text/javascript">
		// states for the various panes that can be visible
		// true is visible, false is not
		var pane_state = {
			vertices : true,
			geometry : true,
			vertex : true,
			fragment : true,
			console : true
		};
		var pane_elements;
		
		function updatePaneVisibility() {
			if (!pane_elements) {
				pane_elements = new Object();
				pane_elements.vertices = document.getElementById('vertex-inputs');
				pane_elements.geometry = document.getElementById('geometry-shader');
				pane_elements.vertex = document.getElementById('vertex-shader');
				pane_elements.fragment = document.getElementById('frag-shader');
				pane_elements.console = document.getElementById('console');
			}
			
			for (var prop in pane_elements) {
				if (pane_state[prop]) {
					removeClass(pane_elements[prop], "invisible");
				}
				else {
					addClass(pane_elements[prop], "invisible");
				}
			}
		}
		
		function toggle(pane) {
			LogConsole("Changing visibility of " + pane);
			// ignores calls that don't refer to a proper pane
			if (pane_state.hasOwnProperty(pane)) {
				pane_state[pane] = !pane_state[pane];
			}
			
			updatePaneVisibility();
		}
	</script>
	<script>
		var Vertex = {
			position : new Float32Array([0.0, 0.0, 0.0, 0.0]),
			normal : new Float32Array([0.0, 0.0, 0.0]),
			color : new Float32Array([0.0, 0.0, 0.0, 1.0]),
			texcoord : new Float32Array([0.0, 0.0])
		};
		var vertices;
		function parseObj(str) {
			// currently does a naive conversion, ends up with non-indexed geometry
			// TODO try to convert obj indexed geometry to indexed VBO (make a hashset, index in on string of the combination)
			var lines = str.split("\n");
			var positions = new Array();
			var normals = new Array();
			var texcoords = new Array();
			var vert_objs = new Array();
			var faces = new Array();
			
			for (var idx = 0; idx < lines.length; ++idx) {
				var token = lines[idx].match(/[A-Za-z#]+/);
				if (token == "#" || !token) {
					continue;
				}
				var values = lines[idx].match(/[0-9.-]+/g);
				if (token == "v") {
					var tmp = new Float32Array(4);
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0,0,1)
					tmp[1] = values[1] || 0.0;
					tmp[2] = values[2] || 0.0;
					tmp[3] = values[3] || 1.0;
					positions.push(tmp);
				}
				else if (token == "vt") {
					var tmp = new Float32Array(2);
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0)
					tmp[1] = values[1] || 0.0;
					texcoords.push(tmp);
				}
				else if (token == "vn") {
					var tmp = new Float32Array(3);
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0,0,1)
					tmp[1] = values[1] || 0.0;
					tmp[3] = values[3] || 1.0;
					normals.push(tmp);
				}
				else if (token == "f") {
					values = lines[idx].match(/[0-9\/]+/g);
					LogConsole("Rematch face: " + values);
					if (values) {
						for (var val in values) {
							// need to prevent duplicates
							vert_objs.push(values[val]);
						}
						faces.push(values);
					}
					else {
						LogConsoleError("Face found with null value on line " + (idx + 1) + ": " + lines[idx]);
					}
				}
				else {
					LogConsoleError("Unknown or un-implemented starting token " + token);
					continue;
				}
			}
			LogConsole(positions);
			LogConsole(vert_objs);
		}
	</script>
</head>
<body>
	<div class="overlay top nav">		
		<a href="#vertices" onclick="toggle('vertices');">Vertices       </a>
		<a href="#geometry" onclick="toggle('geometry');">Geometry Shader</a>
		<a href="#vertex"   onclick="toggle('vertex');"  >Vertex Shader  </a>
		<a href="#fragment" onclick="toggle('fragment');">Fragment Shader</a>
	</div>
	<canvas id="context"></canvas>
	<div class="multi-pane">
		<textarea class="resizable overlay" id="vertex-inputs" onchange="updateShaders();">
# can hand specify obj file or copy and paste
# currently does not support full objfile, ignores materials, 
#	objects, groups, smoothing groups, and parameter space vertices

# vertices
v 0.0 0.0 0.0 1.0
v 1.0 0.0 0.0 1.0
v 1.0 1.0 0.0 1.0
v 0.0 1.0 0.0 1.0

# texture coordinates
vt 0.0 1.0
vt 1.0 1.0
vt 1.0 0.0
vt 0.0 0.0

# normals
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0

# face definitions
f 0/0/0 1/1/1 2/2/2
f 0/0/0 2/2/2 3/3/3 
		</textarea>
		<textarea class="resizable overlay" id="geometry-shader" onchange="updateShaders();">
precision mediump float;
// currently ignoring geometry shaders as more frequently I use vertex/fragment
// apparently webgl has no geometry shaders so this will get replaced with some sort of pass editor
// additionally having a thing that you can input javascript and have it be used as a function to 
// generate geometry would be pretty darn useful, if I can figure out how to make that safe
		</textarea>
		<textarea class="resizable overlay" id="vertex-shader" onchange="updateShaders();">
precision mediump float;

attribute vec4 position;
attribute vec4 normal;
attribute vec4 color;
attribute vec2 uv;

varying vec4 vs_color;
varying vec2 vs_uv;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main(void) {
	// default: multiply the transform matrices and multiply the position by the transforms
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;
	
	// default: pass the color and texture coordinate to the fragment shader
	vs_color = color;
	vs_uv = uv;
}
		</textarea>
		<textarea class="resizable overlay" id="frag-shader" onchange="updateShaders();">
precision mediump float;

varying vec4 vs_color;
varying vec2 vs_uv;

void main(void) {
	// default: pass the color through
	gl_FragColor = vs_color;
}
		</textarea>
		<div class="float-clear overlay" id="console"></div>
	</div>
	<script>
		var canvas = document.getElementById("context");
		init(canvas);
	</script>
</body>
</html>