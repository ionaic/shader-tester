<!DOCTYPE html>
<html>
<head>
	<style type="text/css">
		body, a, div, p {
			color: #0066CC;
		}
		a {
			text-decoration: none;
		}
		textarea {
			width: 45%;
			height: 45%;
		}
		.top {
			margin: 10px auto;
			top: 0;
			left: 0;
		}
		.nav {
			display: table;
		}
		.nav > * {
			display: table-cell;
			padding: 10px;
		}
		.multi-pane {
			position: absolute;
			top: 50px;
			width: 100%;
			height: 100%;
			margin: 10px auto;
		}
		.multi-pane > * {
			float: left;
		}
		.resizable {
			resize: both;
		}
		.float-clear {
			float: clear !important;
		}
		.invisible {
			display: none;
		}
		.overlay {
			z-index: 10;
			transition: 		background-color 0.3s ease-in 0s;
			-webkit-transition: background-color 0.3s ease-in 0s;
			-moz-transition: 	background-color 0.3s ease-in 0s;
			-o-transition:		background-color 0.3s ease-in 0s;
			-ms-transition:		background-color 0.3s ease-in 0s;
			background-color: rgba(0, 0, 0, 0.0);
			text-shadow: 0.3px 0.3px #000;
			color: #0066CC;
		}
		.overlay:hover, .overlay:active, .overlay:focus {
			background-color: rgba(0, 0, 0, 0.9);
		}
		.gl-console-error {
			color: red;
		}
		#console {
			margin: 10px auto;
			overflow: scroll;
			resize: both;
			/* border: solid 3px #333;*/
		}
		#context {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			z-index: -1;
		}
	</style>
	<script type="text/javascript">
		// utilities
		var gl_console = null;
		
		// error logging
		function CreateConsoleMessage(message) {
			// TODO sanitize the messages
			var p = document.createElement("pre");
			var text = document.createTextNode(message);
			p.appendChild(text);
			return p;
		}
		function LogConsole(message) {
			if (!gl_console) {
				gl_console = document.getElementById("console");
			}
			gl_console.appendChild(CreateConsoleMessage(message));
		}
		function LogConsoleError(message) {
			if (!gl_console) {
				gl_console = document.getElementById("console");
			}
			var console_element = CreateConsoleMessage(message);
			addClass(console_element, "gl-console-error");
			gl_console.appendChild(console_element);
		}
		function ObjectToString(obj, depth) {
			if (!depth) {
				depth = 0;
			}
			var tabdepth = new Array(depth + 1).join("\t");
			var str = tabdepth + "{\n";
			for (var prop in obj) {
				str += tabdepth + "\t" + prop + " : ";
				if (typeof obj[prop] == "object") {
					str += ObjectToString(obj[prop], depth + 1);
				}
				else {
					str += obj[prop];
				}
				str += ",\n";;
			}
			str += tabdepth + "}";
			return str;
		}
		
		/* add a class */
		function addClass(obj, selected_class) {
			if (obj.className === undefined) {
				obj.className = selected_class;
			}
			else {
				classes = obj.className.split(' ');
				if (classes.indexOf === undefined) {
					// going the long way for older browsers
					for (var i = 0; i < classes.length; i++) {
						if (classes[i] === selected_class) {
							break;
						}
					}
				}
				else {
					var idx = classes.indexOf(selected_class);
					if (idx < 0) {
						classes.push(selected_class);
					}
				}
				obj.className = classes.join(" ");
			}
			return obj;
		}

		/* remove a class */
		function removeClass(obj, selected_class) {
			if (obj.className === undefined) {
				obj.className = "";
			}
			else {
				classes = obj.className.split(' ');
				if (classes.indexOf === undefined) {
					// going the long way for older browsers
					for (var i = 0; i < classes.length; i++) {
						if (classes[i] === selected_class) {
							classes.splice(i, 1);
						}
					}
				}
				else {
					var idx = classes.indexOf(selected_class);
					if (idx >= 0) {
						classes.splice(idx, 1);
					}
				}
				obj.className = classes.join(" ");
			}
			return obj;
		}
	</script>
	<script type="text/javascript">
		var gl;
		var shader = {
			program : null,
			vert : null,
			frag : null,
			geom : null
		};
		var vert_data;
		
		function initShaders() {
			if (!gl) {
				LogConsole("In function initShaders, GL not initialized, creating")
				return;
			}
			// create the program
			shader.program = gl.createProgram();
			
			// create the shaders
			shader.vert = gl.createShader(gl.VERTEX_SHADER);
			shader.frag = gl.createShader(gl.FRAGMENT_SHADER);
			
			// load the shader sources
			var vs_el = document.getElementById("vertex-shader");
			var fs_el = document.getElementById("frag-shader");
			gl.shaderSource(shader.vert, vs_el.value);
			gl.shaderSource(shader.frag, fs_el.value);
			
			// compile vertex shader and log errors
			gl.compileShader(shader.vert);
			LogConsole("Compiling vertex shader...");
			if (!gl.getShaderParameter(shader.vert, gl.COMPILE_STATUS)) {
				LogConsoleError(gl.getShaderInfoLog(shader.vert));
			}
			else {
				LogConsole(gl.getShaderParameter(shader.vert, gl.COMPILE_STATUS));
				LogConsole(gl.getShaderInfoLog(shader.vert));
			}
			
			// compile fragment shader and log errors
			gl.compileShader(shader.frag);
			LogConsole("Compiling fragment shader...");
			if (!gl.getShaderParameter(shader.frag, gl.COMPILE_STATUS)) {
				LogConsoleError(gl.getShaderInfoLog(shader.frag));
			}
			else {
				LogConsole(gl.getShaderParameter(shader.frag, gl.COMPILE_STATUS));
				LogConsole(gl.getShaderInfoLog(shader.frag));
			}
		}
		
		function updateShaders() {
			if (!gl) {
				LogConsole("In function updateShaders, GL not initialized, creating");
				return;
			}
			LogConsole("Update Shaders");
		}
		
		function initBuffers() {
			if (!gl) {
				LogConsole("In function initBuffers, GL not initialized, creating");
				return;
			}
		}

		function init(canvas) {
			try {
				gl = canvas.getContext("webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
			catch (e) {}
			if (!gl) {
				LogConsoleError("Could not initialize WebGL context");
			}
			else {
				LogConsole("WebGL Context initialized");
			}
			
			initShaders();
			
			updatePaneVisibility();
			parseObj(pane_elements.vertices.value);
		}
	</script>
	<script type="text/javascript">
		// states for the various panes that can be visible
		// true is visible, false is not
		var pane_state = {
			vertices : true,
			geometry : true,
			vertex : true,
			fragment : true,
			console : true
		};
		var pane_elements;
		
		function updatePaneVisibility() {
			if (!pane_elements) {
				pane_elements = {};
				pane_elements.vertices = document.getElementById('vertex-inputs');
				pane_elements.geometry = document.getElementById('geometry-shader');
				pane_elements.vertex = document.getElementById('vertex-shader');
				pane_elements.fragment = document.getElementById('frag-shader');
				pane_elements.console = document.getElementById('console');
			}
			
			for (var prop in pane_elements) {
				if (pane_state[prop]) {
					removeClass(pane_elements[prop], "invisible");
				}
				else {
					addClass(pane_elements[prop], "invisible");
				}
			}
		}
		
		function toggle(pane) {
			LogConsole("Changing visibility of " + pane);
			// ignores calls that don't refer to a proper pane
			if (pane_state.hasOwnProperty(pane)) {
				pane_state[pane] = !pane_state[pane];
			}
			
			updatePaneVisibility();
		}
	</script>
	<script>
		var Vertex = function() {
			this.position 	= [0.0, 0.0, 0.0, 0.0];
			this.normal 	= [0.0, 0.0, 0.0];
			this.texcoord 	= [0.0, 0.0];
			this.color 		= [0.0, 0.0, 0.0, 1.0];
			this.GetDataArray = function() {
				// guarantee that we have default values in case of undefined
				return (this.position || this.prototype.position).concat(this.normal || this.prototype.position, this.texcoord || this.prototype.texcoord, this.color || this.prototype.color);
			};
		};
		var vertices_objects;
		var vertices_data;
		var indices;
		
		function parseObj(str) {
			// currently does a naive conversion, ends up with non-indexed geometry
			// TODO try to convert obj indexed geometry to indexed VBO (make a hashset, index in on string of the combination)
			LogConsole("Parsing OBJ...");
			var lines = str.split("\n");
			var verts = {};
			
			var positions = [];
			var normals = [];
			var texcoords = [];
			var vert_objs = {};
			var faces = [];
			
			// parse the obj string into arrays
			for (var idx = 0; idx < lines.length; ++idx) {
				var token = lines[idx].match(/[A-Za-z#]+/);
				if (token == "#" || !token) {
					continue;
				}
				var values = lines[idx].match(/[0-9.-]+/g);
				if (token == "v") {
					var tmp = [];
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0,0,1)
					tmp[1] = values[1] || 0.0;
					tmp[2] = values[2] || 0.0;
					tmp[3] = values[3] || 1.0;
					positions.push(tmp);
				}
				else if (token == "vt") {
					var tmp = [];
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0)
					tmp[1] = values[1] || 0.0;
					texcoords.push(tmp);
				}
				else if (token == "vn") {
					var tmp = [];
					tmp[0] = values[0] || 0.0; // if value parsing failed, default to (0,0,0,1)
					tmp[1] = values[1] || 0.0;
					tmp[3] = values[3] || 1.0;
					normals.push(tmp);
				}
				else if (token == "f") {
					values = lines[idx].match(/[0-9\/]+/g);
					if (values) {
						for (var val in values) {
							// need to prevent duplicates, use object as set
							vert_objs[values[val]] = -1;
						}
						faces.push(values.join(" "));
					}
					else {
						LogConsoleError("Face found with null value on line " + (idx + 1) + ": " + lines[idx]);
					}
				}
				else {
					LogConsoleError("Unknown or un-implemented starting token " + token);
					continue;
				}
			}
			
			// produce the vertex objects to be indexed
			for (var v in vert_objs) {
				var idxs = v.split("/");
				
				var tmp_v = new Vertex();
				tmp_v.position = positions[idxs[0]];
				tmp_v.texcoord = texcoords[idxs[1]];
				tmp_v.normal = normals[idxs[2]];
				
				if (!tmp_v.position) {
					LogConsoleError("No vertex defined for index " + idxs[0] + " in face definition " + idxs + "\n\tMax index defined is " + (positions.length-1));
					continue;
				}
				if (!tmp_v.texcoord && idxs[1] >= 0) {
					LogConsoleError("No texture coordinate defined for index " + idxs[1] + " in face definition " + idxs + "\n\tMax index defined is " + (texcoords.length - 1));
				}
				if (!tmp_v.normal && idxs[2] >= 0) {
					LogConsoleError("No vertex normal defined for index " + idxs[2] + " in face definition " + idxs + "\n\tMax index defined is " + (normals.length-1));
				}
				verts[v] = tmp_v;
			}
			
			// set up indices
			vertices = [];
			indices = [];
			LogConsole(faces);
			for (var f in faces) {
				var tmp_f = faces[f].split(" ");
				
				// TODO currently require the definitions to be triangle faces
				for (var idx = 0; idx < 3; ++idx) {
					// fill in a default vertex if it does not exist
					// undefined vertex values filled in by the GetDataArray function
					if (verts[tmp_f[idx]]) {
						// if this value is -1, then it has not been added to the vertices array yet
						if (vert_objs[tmp_f[idx]] < 0) {
							vertices.push(verts[tmp_f[idx]]);
							
							LogConsole("Adding vertex " + tmp_f[idx] + " at index " + (vertices.length - 1));
							
							vert_objs[tmp_f[idx]] = vertices.length - 1;
						}
					}
					else {
						vertices.push((new Vertex()));
						
						LogConsoleError("No vertex found at index " + tmp_f[idx] + "\n\tin face " + f + ": " + faces[f] + "\nFilling in default vertex at index " + (vertices.length - 1));
						
						vert_objs[tmp_f[idx]] = vertices.length - 1;
					}
					indices.push(vert_objs[tmp_f[idx]]);
				}
				if (tmp_f.length > 3) {
					LogConsoleError("Extra vertices given for face definition, currently requires triangle faces.\n\tface " + f + ": " + faces[f]);
				}
			}
			
			vertices_data = new Float32Array([].concat.apply([], vertices.map(function(val) { return val.GetDataArray(); })));
			
			LogConsole("OBJ Parsing done.");
		}
	</script>
</head>
<body>
	<div class="overlay top nav">		
		<a href="#vertices" onclick="toggle('vertices');">Vertices       </a>
		<a href="#geometry" onclick="toggle('geometry');">Geometry Shader</a>
		<a href="#vertex"   onclick="toggle('vertex');"  >Vertex Shader  </a>
		<a href="#fragment" onclick="toggle('fragment');">Fragment Shader</a>
	</div>
	<canvas id="context"></canvas>
	<div class="multi-pane">
		<textarea class="resizable overlay" id="vertex-inputs" onchange="parseObj(this.value);">
# can hand specify obj file or copy and paste
# currently does not support full objfile, ignores materials, 
#	objects, groups, smoothing groups, and parameter space vertices

# vertices
v 0.0 0.0 0.0 1.0
v 1.0 0.0 0.0 1.0
v 1.0 1.0 0.0 1.0
v 0.0 1.0 0.0 1.0

# texture coordinates
vt 0.0 1.0
vt 1.0 1.0
vt 1.0 0.0
vt 0.0 0.0

# normals
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0

# face definitions
f 0/0/0 1/1/1 2/2/2
f 0/0/0 2/2/2 3/3/3 
		</textarea>
		<textarea class="resizable overlay" id="geometry-shader" onchange="updateShaders();">
precision mediump float;
// currently ignoring geometry shaders as more frequently I use vertex/fragment
// apparently webgl has no geometry shaders so this will get replaced with some sort of pass editor
// additionally having a thing that you can input javascript and have it be used as a function to 
// generate geometry would be pretty darn useful, if I can figure out how to make that safe
		</textarea>
		<textarea class="resizable overlay" id="vertex-shader" onchange="updateShaders();">
precision mediump float;

attribute vec4 position;
attribute vec4 normal;
attribute vec4 color;
attribute vec2 uv;

varying vec4 vs_color;
varying vec2 vs_uv;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main(void) {
	// default: multiply the transform matrices and multiply the position by the transforms
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;
	
	// default: pass the color and texture coordinate to the fragment shader
	vs_color = color;
	vs_uv = uv;
}
		</textarea>
		<textarea class="resizable overlay" id="frag-shader" onchange="updateShaders();">
precision mediump float;

varying vec4 vs_color;
varying vec2 vs_uv;

void main(void) {
	// default: pass the color through
	gl_FragColor = vs_color;
}
		</textarea>
		<div class="float-clear overlay" id="console"></div>
	</div>
	<script>
		var canvas = document.getElementById("context");
		init(canvas);
	</script>
</body>
</html>